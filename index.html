/**
 * RAVE CAVE - Wine Cellar Management System
 * Sommelier Agent - Google Apps Script Backend
 * 
 * Version: 2.0 - Optimized & Streamlined
 * Last Updated: January 31, 2026
 * Model: Gemini 3 Flash Preview
 * 
 * Features:
 * - AI wine label recognition with photo upload to Google Drive
 * - Natural conversation sommelier assistant with unlimited conversation depth
 * - Automated drinking window, maturity status, and tasting notes
 * - Duplicate wine detection (updates quantity instead of creating duplicates)
 * - Multi-turn conversation support with full context retention
 * - Optimized performance (removed debug overhead, streamlined API calls)
 * 
 * @OnlyCurrentDoc false
 */

/**
 * Explicitly declare required OAuth scopes
 * This triggers authorization prompt for Drive access
 */
// @ts-ignore
var SCOPES = [
  'https://www.googleapis.com/auth/spreadsheets',
  'https://www.googleapis.com/auth/drive',
  'https://www.googleapis.com/auth/script.external_request'
];

const SHEET_NAME = 'Master_Wine_Cellar_Complete'; // UPDATE THIS to match your Google Sheet tab name

/**
 * Main chat function - handles conversation with Gemini
 * @param {Array} history - Conversation history in Gemini format
 * @param {number} retryCount - Current retry attempt (for exponential backoff)
 * @returns {string} AI response text
 */
function chatWithSommelier(history, retryCount = 0) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`;
  
  // Get current wine inventory for context
  const inventoryContext = getInventoryContext();
  
  // System instruction with inventory context
  const systemInstruction = `You are a sophisticated French sommelier with deep wine knowledge and expertise in building well-rounded wine collections.

üç∑ CONVERSATION STYLE:
- Be warm, knowledgeable, and conversational - like a friendly wine expert at a dinner party
- Share your wine knowledge naturally without being rigid or overly formal
- When asked about wines (ratings, quality, characteristics), give your expert opinion based on your knowledge
- You can discuss wine quality, typical ratings, producer reputation, and vintage characteristics from your training
- Only mention searching the web if you truly don't know something or need very current pricing/availability
- For questions like "what would you rate this wine?" - give an honest assessment based on producer, region, vintage, style
- Be direct and helpful, not cautious or evasive

EXAMPLE NATURAL RESPONSES:
User: "What would you rate the 2021 Kilikanoon Parable?"
Good: "The Parable is one of Kilikanoon's premium offerings - I'd rate it around 93-95/100. It's a beautifully crafted Clare Valley Shiraz with excellent structure and aging potential. The 2021 vintage was quite strong in the Clare Valley, so this should be drinking beautifully in 3-5 years and will cellar well for 10-15."
Bad: "I recommend checking Wine-Searcher.com for ratings..."

User: "Is this wine any good?"
Good: "Absolutely! Penfolds Grange is one of Australia's most iconic wines - consistently rated 95-100 points. It's a benchmark Shiraz that ages magnificently."
Bad: "I suggest exploring Vivino.com for community reviews..."
    
THE COMPLETE CELLAR INVENTORY IS LISTED BELOW:
${inventoryContext}

‚ö†Ô∏è CRITICAL - HOW TO ANSWER QUANTITY QUESTIONS:
When asked "how many X do I have?", follow these steps:
1. SEARCH the inventory list above for the wine name
2. FIND the line that matches
3. READ the "Quantity: X bottles" on that line
4. ANSWER with that number

EXAMPLE:
User: "How many Block 6 Riesling do I have?"
You: [Search list above for "Block 6"] ‚Üí Find: "2019 Colmar Estate "Block 6 Riseling" from Orange | Quantity: 2 bottles"
You answer: "You have 2 bottles of the 2019 Colmar Estate Block 6 Riesling."

DO NOT call getInventory, checkInventory, or any other function to answer quantity questions. The answer is RIGHT THERE in the list above.

üì∏ WINE LABEL PHOTO ANALYSIS & FIELD REQUIREMENTS:

When user sends a photo of a wine label, extract and estimate ALL fields:

**MANDATORY FIELDS (must ask if unclear):**
- Producer: The winery/maker name (REQUIRED - ask if unclear)
- Vintage: Year or "NV" for non-vintage blends (REQUIRED - ask if unclear)
- Wine Type: MUST be exactly one of: "Red", "White", "Sparkling", "Dessert", "Fortified", "Orange", "Ros√©" (REQUIRED)
- C√©page: Grape variety (REQUIRED - ask if unclear)
- Blend %: "100%" if single varietal, otherwise estimate percentages (REQUIRED)
- Region: Growing region (REQUIRED - ask if unclear)
- Country: Country of origin (REQUIRED - ask if unclear)

**OPTIONAL FIELDS:**
- Wine Name: ONLY if wine has special designation (e.g., "Hill of Grace", "Grange") - leave blank otherwise
- Appellation: If visible on label

**FIELDS YOU MUST ESTIMATE:**
- Drink From: Earliest optimal drinking year (estimate based on vintage, region, grape)
- Drink Until: Latest optimal drinking year (estimate based on wine type and quality level)
- Maturity: MUST be exactly one of: "üü¢ Hold", "üç∑ Drink Now", "‚ö†Ô∏è Past Peak"
  * Use "üü¢ Hold" for wines still developing (not yet at peak)
  * Use "üç∑ Drink Now" for wines at their peak drinking window
  * Use "‚ö†Ô∏è Past Peak" for wines past their optimal drinking window
- Tasting Notes: Generate concise notes using 1-2 word descriptors separated by commas. Max 150 chars. Examples: "blackberry, cedar, tobacco" or "citrus, mineral, crisp"

**CONFIRMATION FLOW:**
1. Extract all visible details from photo
2. Estimate drinking windows and generate tasting notes
3. Present concise confirmation: "üì∏ **[YEAR] [PRODUCER] [WINE NAME]**
   - Type: [TYPE] | Region: [REGION], [COUNTRY]
   - Grape: [C√âPAGE] ([BLEND%])
   - Drink: [YEAR-YEAR] | Maturity: [STATUS]
   - Notes: [notes]
   
   How many bottles?"
4. Wait for quantity
5. Call addWine with ALL fields (leave vivinoRating blank)

**Example:**
User: [sends photo]
You: "üì∏ **2019 Penfolds Grange**
- Type: Red | Region: Barossa Valley, Australia  
- Grape: Shiraz (100%)
- Drink: 2025-2045 | Maturity: üü¢ Hold
- Notes: blackcurrant, eucalyptus, dark chocolate, oak, powerful tannins

How many bottles?"

User: "add 3"
You: [Call addWine with all fields, vivinoRating blank]

User: "2 bottles"
You: [Call addWine with wineType="Red", maturity="üü¢ Hold", vivinoRating="4.5", and all other fields]

YOUR THREE TOOLS:
1. addWine - Use after confirming wine details from photo or manual entry
2. removeWine - ONLY when user drinks/opens a bottle
3. searchWineRecommendations - ONLY for wine buying research

‚ùå FORBIDDEN FUNCTIONS (DO NOT CALL THESE):
getInventory, checkInventory, searchWines, listWines, getWineInventory - NONE OF THESE EXIST

CAPABILITIES:
- Extract wine data from label photos
- Answer inventory questions by READING the list above
- Analyze collection gaps and suggest purchases
- Provide pairing recommendations

FORMATTING:
Use **bold**, *, ###, --- for readable formatting

Be accurate, helpful, and passionate about wine!`;

  // Clean history: remove empty messages but keep image messages
  let cleanedHistory = history.filter(item => {
    if (!item.parts || item.parts.length === 0) {
      return false; // Remove if no parts
    }
    
    // Check if message has at least one valid part (text or image)
    const hasValidPart = item.parts.some(part => {
      // Has text?
      if (part.text && part.text.trim() !== "") return true;
      // Has image?
      if (part.inline_data) return true;
      return false;
    });
    
    return hasValidPart;
  });

  // Use full conversation history - no artificial limits
  // Gemini can handle long conversations, and deep wine discussions are valuable
  let contents = cleanedHistory;

  // Build the payload with proper systemInstruction
  const payload = {
    contents: contents,
    systemInstruction: {
      parts: [{
        text: systemInstruction
      }]
    },
    tools: [{
      function_declarations: [
        {
          name: "addWine",
          description: "Adds a new wine to the cellar after user confirms the details extracted from a photo or provided manually. You must estimate drinking windows, maturity, and generate tasting notes.",
          parameters: {
            type: "OBJECT",
            properties: {
              producer: { type: "STRING", description: "Wine producer/maker (REQUIRED)" },
              wineName: { type: "STRING", description: "Specific wine name/cuv√©e (optional - only if wine has a special designation like 'Hill of Grace')" },
              vintage: { type: "STRING", description: "Vintage year or 'NV' for non-vintage blends (REQUIRED)" },
              wineType: { 
                type: "STRING", 
                description: "Wine type (REQUIRED) - MUST be one of: 'Red', 'White', 'Sparkling', 'Dessert', 'Fortified', 'Orange', 'Ros√©'",
                enum: ["Red", "White", "Sparkling", "Dessert", "Fortified", "Orange", "Ros√©"]
              },
              cepage: { type: "STRING", description: "Grape variety/varieties (REQUIRED)" },
              blendPercent: { type: "STRING", description: "Blend percentages (REQUIRED - default to '100%' if single varietal)" },
              appellation: { type: "STRING", description: "Appellation/AVA (optional)" },
              region: { type: "STRING", description: "Wine region (REQUIRED)" },
              country: { type: "STRING", description: "Country of origin (REQUIRED)" },
              quantity: { type: "NUMBER", description: "Number of bottles (default 1)" },
              drinkFrom: { type: "STRING", description: "Estimated earliest drinking year (REQUIRED - you must estimate)" },
              drinkUntil: { type: "STRING", description: "Estimated latest drinking year (REQUIRED - you must estimate)" },
              maturity: { 
                type: "STRING", 
                description: "Current maturity status (REQUIRED) - MUST be one of: 'üü¢ Hold', 'üç∑ Drink Now', '‚ö†Ô∏è Past Peak'",
                enum: ["üü¢ Hold", "üç∑ Drink Now", "‚ö†Ô∏è Past Peak"]
              },
              tastingNotes: { type: "STRING", description: "Concise tasting notes - 1-2 word descriptors separated by commas, max 150 chars (REQUIRED - you must generate)" },
              driveImageId: { type: "STRING", description: "Google Drive file ID for label image" }
            },
            required: ["producer", "vintage", "wineType", "cepage", "blendPercent", "region", "country", "drinkFrom", "drinkUntil", "maturity", "tastingNotes"]
          }
        },
        {
          name: "removeWine",
          description: "Removes one bottle from inventory when wine is consumed. Decrements quantity by 1, or deletes row if last bottle.",
          parameters: {
            type: "OBJECT",
            properties: { 
              producer: { 
                type: "STRING",
                description: "The wine producer/maker name"
              }, 
              vintage: { 
                type: "NUMBER",
                description: "The vintage year of the wine"
              }
            },
            required: ["producer", "vintage"]
          }
        },
        {
          name: "searchWineRecommendations",
          description: "Search the web for wine recommendations, buying guides, and information about specific wine regions or styles. Use this to help with purchase decisions and gap analysis.",
          parameters: {
            type: "OBJECT",
            properties: {
              query: {
                type: "STRING",
                description: "Search query for wine information (e.g. 'best Burgundy wines under $100', 'classic Barolo producers', 'Italian red wine regions')"
              }
            },
            required: ["query"]
          }
        }
      ]
    }]
  };

  try {
    const response = UrlFetchApp.fetch(url, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    
    const result = JSON.parse(response.getContentText());
    Logger.log('Gemini API Response: ' + JSON.stringify(result));

    // Handle API errors
    if (result.error) {
      Logger.log("API Error: " + result.error.message);
      
      // Return full error details for debugging
      const errorDetails = "Code: " + result.error.code + "\nMessage: " + result.error.message + "\nStatus: " + result.error.status;
      
      // Check if overloaded and retry
      if ((result.error.message.includes("overloaded") || result.error.code === 503 || result.error.code === 429) && retryCount < 3) {
        Logger.log("API overloaded (from response), retrying... (attempt " + (retryCount + 1) + ")");
        Utilities.sleep(Math.pow(2, retryCount) * 1000);
        return chatWithSommelier(history, retryCount + 1);
      }
      
      return "üç∑ API Error:\n" + errorDetails;
    }

    // Check for valid response
    if (!result.candidates || !result.candidates[0] || !result.candidates[0].content) {
      Logger.log("No valid response from Gemini. Full result: " + JSON.stringify(result));
      return "ü§î No response from AI. Please try again.";
    }

    let candidate = result.candidates[0];
    let part = candidate.content.parts[0];
    
    Logger.log("Candidate content: " + JSON.stringify(candidate.content));
    Logger.log("First part: " + JSON.stringify(part));

    // Handle Function Calls (tool use)
    if (part.functionCall) {
      const call = part.functionCall;
      let toolData;
      
      if (call.name === "addWine") {
        toolData = addWine(call.args);
      } else if (call.name === "removeWine") {
        toolData = runRemoveWine(call.args);
      } else if (call.name === "searchWineRecommendations") {
        toolData = searchWineRecommendations(call.args);
      } else {
        return "Unknown function requested: " + call.name;
      }

      // Send function response back to Gemini for final natural language answer
      const secondPayload = {
        contents: [
          ...payload.contents,
          candidate.content, // The function call
          { 
            role: "function", 
            parts: [{ 
              functionResponse: { 
                name: call.name, 
                response: { 
                  name: call.name,
                  content: toolData 
                } 
              } 
            }] 
          }
        ],
        tools: payload.tools // Keep tools available
      };

      const secondResponse = UrlFetchApp.fetch(url, {
        method: 'POST',
        contentType: 'application/json',
        payload: JSON.stringify(secondPayload),
        muteHttpExceptions: true
      });
      
      const secondResult = JSON.parse(secondResponse.getContentText());
      Logger.log('Second response after function call: ' + JSON.stringify(secondResult));
      
      // Check for errors in second response
      if (secondResult.error) {
        Logger.log("Error in second call: " + secondResult.error.message);
        // Return the tool result directly if Gemini can't format it
        return toolData;
      }
      
      if (secondResult.candidates && secondResult.candidates[0] && secondResult.candidates[0].content) {
        const parts = secondResult.candidates[0].content.parts;
        if (parts && parts.length > 0 && parts[0].text) {
          return parts[0].text;
        }
      }
      
      // Fallback: return the tool result directly
      Logger.log('No text in second response, returning tool data directly');
      return toolData;
    }

    // Return regular text response
    const textResponse = part.text || "";
    if (!textResponse || textResponse.trim() === "") {
      Logger.log("WARNING: No text in part. Part structure: " + JSON.stringify(part));
      return "I received your message but couldn't formulate a response. Please try again.";
    }
    return textResponse;
    
  } catch (e) { 
    Logger.log("Exception: " + e.toString());
    
    // Check if it's an overload error and retry
    const errorStr = e.toString();
    if ((errorStr.includes("overloaded") || errorStr.includes("503") || errorStr.includes("429")) && retryCount < 3) {
      Logger.log("API overloaded, retrying... (attempt " + (retryCount + 1) + ")");
      
      // Exponential backoff: wait 1s, 2s, 4s
      Utilities.sleep(Math.pow(2, retryCount) * 1000);
      
      return chatWithSommelier(history, retryCount + 1);
    }
    
    return "üö® Connection error: " + e.toString(); 
  }
}

/**
 * Upload image to Google Drive and return public URL
 * @param {string} base64Data - Base64 encoded image
 * @param {string} fileName - Name for the file
 * @returns {object} {fileId, url, error}
 */
function uploadImageToDrive(base64Data, fileName) {
  try {
    // Check if we have data
    if (!base64Data) {
      return { error: "No base64 data provided" };
    }
    
    // Decode base64
    let blob;
    try {
      const decoded = Utilities.base64Decode(base64Data);
      blob = Utilities.newBlob(decoded, 'image/jpeg', fileName);
    } catch (decodeError) {
      return { error: "Base64 decode failed: " + decodeError.toString() };
    }
    
    // Get or create Wine Labels folder
    const folderName = 'Wine Labels - RAVE CAVE';
    let folder;
    try {
      const folders = DriveApp.getFoldersByName(folderName);
      if (folders.hasNext()) {
        folder = folders.next();
      } else {
        folder = DriveApp.createFolder(folderName);
      }
    } catch (folderError) {
      return { error: "Folder creation failed: " + folderError.toString() };
    }
    
    // Upload file
    let file;
    try {
      file = folder.createFile(blob);
    } catch (uploadError) {
      return { error: "File upload failed: " + uploadError.toString() };
    }
    
    const fileId = file.getId();
    
    // Make it publicly viewable with multiple methods
    try {
      file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
      file.setShareableByEditors(false);
    } catch (shareError) {
      return { error: "Sharing failed: " + shareError.toString(), fileId: fileId };
    }
    
    // Generate public URL - use thumbnail which works better for images
    const url = `https://drive.google.com/thumbnail?id=${fileId}&sz=w500`;
    
    return { fileId: fileId, url: url };
  } catch (e) {
    return { error: "General error: " + e.toString() };
  }
}

/**
 * Add new wine to the cellar
 * @param {Object} args - Wine details
 * @returns {string} Confirmation message
 */
function addWine(args) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
    
    // Get Drive image URL - either from args or from temp storage
    let imageUrl = '';
    let driveImageId = args.driveImageId;
    
    Logger.log('addWine called with args: ' + JSON.stringify(args));
    Logger.log('driveImageId from args: ' + driveImageId);
    
    if (!driveImageId) {
      // Check if there's a temp ID from recent image upload
      driveImageId = PropertiesService.getScriptProperties().getProperty('TEMP_DRIVE_IMAGE_ID');
      Logger.log('Retrieved TEMP_DRIVE_IMAGE_ID: ' + driveImageId);
      // Clear it after use
      PropertiesService.getScriptProperties().deleteProperty('TEMP_DRIVE_IMAGE_ID');
    }
    
    if (driveImageId) {
      imageUrl = `https://drive.google.com/uc?id=${driveImageId}`;
      Logger.log('Generated image URL: ' + imageUrl);
    } else {
      Logger.log('WARNING: No Drive image ID found!');
    }
    
    // Check if wine already exists (same producer, vintage, wine name OR c√©page if no wine name)
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const existingProducer = row[0];
      const existingWineName = row[1];
      const existingVintage = row[2];
      const existingCepage = row[4]; // C√©page column
      
      // Match on producer + vintage + (wine name OR c√©page)
      const producerMatch = existingProducer === args.producer;
      const vintageMatch = existingVintage.toString() === args.vintage.toString();
      
      // If both have wine names, match on wine name
      // If either lacks wine name, match on c√©page instead
      let wineMatch = false;
      if (args.wineName && existingWineName) {
        wineMatch = existingWineName === args.wineName;
      } else {
        // No wine name - match on c√©page
        wineMatch = existingCepage === args.cepage;
      }
      
      if (producerMatch && vintageMatch && wineMatch) {
        // Wine exists! Update quantity
        const currentQty = parseInt(row[9]) || 0;
        const newQty = currentQty + (parseInt(args.quantity) || 1);
        
        sheet.getRange(i + 1, 10).setValue(newQty); // Column J (Quantity)
        
        Logger.log('Updated existing wine quantity: ' + currentQty + ' -> ' + newQty);
        
        return `‚úÖ Updated! You now have **${newQty} bottles** of ${args.vintage} ${args.producer}${args.wineName ? ' "' + args.wineName + '"' : ' ' + args.cepage}.\n\nüìÖ Drink: ${args.drinkFrom}-${args.drinkUntil}\nüç∑ ${args.tastingNotes}`;
      }
    }
    
    // Wine doesn't exist - add new row
    const rowData = [
      args.producer || '',
      args.wineName || '',
      args.vintage || '',
      args.wineType || '',
      args.cepage || '',
      args.blendPercent || '100%',
      args.appellation || '',
      args.region || '',
      args.country || '',
      args.quantity || 1,
      args.drinkFrom || '',
      args.drinkUntil || '',
      args.maturity || '',
      args.tastingNotes || '',
      '', // My Rating (blank)
      '', // Vivino/AI Rating (blank - will add later)
      '', // Personal Note (blank)
      '', // Link to wine (blank)
      imageUrl
    ];
    
    Logger.log('Appending new row with image URL at position 18: ' + imageUrl);
    sheet.appendRow(rowData);
    
    Logger.log('Added wine: ' + args.vintage + ' ' + args.producer + ' ' + (args.wineName || args.cepage));
    
    const successMessage = `‚úÖ Added ${args.vintage} ${args.producer}${args.wineName ? ' "' + args.wineName + '"' : ' ' + args.cepage} to your cellar${imageUrl ? ' with label photo' : ''}!\n\nüìÖ Drink: ${args.drinkFrom}-${args.drinkUntil}\nüç∑ ${args.tastingNotes}`;
    
    Logger.log('Returning success message: ' + successMessage);
    return successMessage;
  } catch (e) {
    Logger.log('Error in addWine: ' + e.toString());
    return '‚ùå Error adding wine: ' + e.toString();
  }
}

/**
 * Generate AI Quality Score using Gemini (no web scraping needed)
 * @param {Object} args - Wine details
 * @returns {Object} {score, confidence, drinkWindow, styleTags, reason}
 */
/**
 * Search the web for wine recommendations and information
 * @param {Object} args - {query: string}
 * @returns {string} Search results summary
 */
function searchWineRecommendations(args) {
  try {
    Logger.log("Wine search query: " + args.query);
    
    // Provide curated recommendations based on the query
    return `Research suggestion for: "${args.query}"

I recommend exploring:
‚Ä¢ Wine-Searcher.com - for pricing and availability
‚Ä¢ Vivino.com - for ratings and community reviews  
‚Ä¢ Decanter.com - for expert reviews and buying guides
‚Ä¢ Local specialist wine retailers in Australia

I can also analyze your current collection to identify specific gaps and make targeted recommendations based on what you already enjoy.`;
    
  } catch (e) {
    Logger.log("Error in searchWineRecommendations: " + e.toString());
    return "I can provide recommendations based on your collection's gaps.";
  }
}

/**
 * Remove one bottle from inventory
 * @param {Object} args - {producer: string, vintage: number}
 * @returns {string} Status message
 */
function runRemoveWine(args) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    
    Logger.log("Looking for: " + args.producer + " " + args.vintage);
    
    // Find the wine (skip header row)
    for (let i = 1; i < data.length; i++) {
      const producer = data[i][0].toString().toLowerCase();
      const vintage = data[i][2].toString();
      
      if (producer.includes(args.producer.toLowerCase()) && vintage == args.vintage) {
        const quantityCol = 9; // Column J (Quantity)
        let currentQty = parseInt(data[i][quantityCol]) || 1;
        
        if (currentQty > 1) {
          // Decrement quantity
          sheet.getRange(i + 1, quantityCol + 1).setValue(currentQty - 1);
          Logger.log("Reduced quantity to " + (currentQty - 1));
          return `Bottle removed. ${currentQty - 1} remaining.`;
        } else {
          // Delete the row (last bottle)
          sheet.deleteRow(i + 1);
          Logger.log("Deleted last bottle");
          return "Last bottle removed from cellar.";
        }
      }
    }
    
    return "Wine not found in cellar: " + args.producer + " " + args.vintage;
  } catch (e) {
    Logger.log("Error in runRemoveWine: " + e.toString());
    return "Error removing wine: " + e.toString();
  }
}

/**
 * Get formatted inventory context for AI
 * @returns {string} Formatted inventory list
 */
function getInventoryContext() {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
    const rows = sheet.getDataRange().getValues();
    
    if (rows.length <= 1) {
      return "The cellar is currently empty.";
    }
    
    // Format: VINTAGE | PRODUCER | WINE NAME | REGION | QTY: X
    // This makes each wine clearly distinct
    const inventory = rows.slice(1) // Skip header
      .filter(r => r[0] && r[0] !== "") // Filter empty rows
      .map(r => {
        const vintage = r[2] || "NV";
        const producer = r[0] || "Unknown";
        const wineName = r[1] || "Unknown Wine";
        const region = r[7] || "Unknown Region";
        const qty = r[9] || 1;
        
        // Clear format: Each wine is on its own line with all details
        return `${vintage} ${producer} "${wineName}" from ${region} | Quantity: ${qty} bottle${qty > 1 ? 's' : ''}`;
      })
      .join("\n");
    
    return inventory || "The cellar is currently empty.";
  } catch (e) {
    Logger.log("Error getting inventory: " + e.toString());
    return "Error reading cellar inventory.";
  }
}

/**
 * Handle POST requests from the web app
 */
function doPost(e) {
  try {
    const request = JSON.parse(e.postData.contents);
    
    // Handle cell update action
    if (request.action === 'updateCell') {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
      const row = request.row;
      const column = request.column;
      const value = request.value;
      
      // Update the cell (row and column are 1-indexed, but column needs +1 for A1 notation)
      sheet.getRange(row, column + 1).setValue(value);
      
      Logger.log(`Updated cell: Row ${row}, Column ${column}, Value: ${value}`);
      
      return ContentService
        .createTextOutput(JSON.stringify({ success: true }))
        .setMimeType(ContentService.MimeType.JSON)
        .setHeader('Access-Control-Allow-Origin', '*')
        .setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS')
        .setHeader('Access-Control-Allow-Headers', 'Content-Type');
    }
    
    // Get history from request
    let history = request.history || [
      { 
        role: "user", 
        parts: [{ text: request.message || "Hello" }] 
      }
    ];
    
    // Handle image upload if present
    let driveImageId = null;
    if (history.length > 0) {
      const lastMessage = history[history.length - 1];
      
      if (lastMessage.parts) {
        for (let i = 0; i < lastMessage.parts.length; i++) {
          const part = lastMessage.parts[i];
          
          if (part.inline_data && part.inline_data.data) {
            Logger.log('Image detected, uploading to Drive...');
            
            try {
              const timestamp = new Date().getTime();
              const fileName = `wine_label_${timestamp}.jpg`;
              const uploadResult = uploadImageToDrive(part.inline_data.data, fileName);
              
              if (uploadResult && uploadResult.fileId) {
                driveImageId = uploadResult.fileId;
                Logger.log('Image uploaded: ' + driveImageId);
                
                // Store it globally so AI can use it when calling addWine
                PropertiesService.getScriptProperties().setProperty('TEMP_DRIVE_IMAGE_ID', driveImageId);
              } else if (uploadResult && uploadResult.error) {
                Logger.log('Upload error: ' + uploadResult.error);
              }
            } catch (uploadError) {
              Logger.log('Upload exception: ' + uploadError.toString());
            }
          }
        }
      }
    }
    
    const aiResponse = chatWithSommelier(history);
    
    // Safety check: never return empty response
    if (!aiResponse || aiResponse.trim() === '') {
      Logger.log('WARNING: Empty AI response');
      return ContentService
        .createTextOutput(JSON.stringify({ 
          response: "I apologize, I'm having trouble processing that request. Please try again."
        }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    return ContentService
      .createTextOutput(JSON.stringify({ response: aiResponse }))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (err) {
    Logger.log('doPost error: ' + err.toString());
    return ContentService
      .createTextOutput(JSON.stringify({ 
        response: "System error. Please try again."
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Handle OPTIONS requests for CORS preflight
 */
function doOptions(e) {
  return ContentService
    .createTextOutput('')
    .setMimeType(ContentService.MimeType.TEXT)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type')
    .setHeader('Access-Control-Max-Age', '86400');
}

/**
 * Handle GET requests (for testing)
 */
function doGet(e) {
  return ContentService
    .createTextOutput(JSON.stringify({ 
      status: "Sommelier API is running",
      version: "5.0"
    }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Test function - run this to verify setup
 */
function testSommelier() {
  const testHistory = [
    {
      role: "user",
      parts: [{ text: "What wine should I pair with lamb?" }]
    }
  ];
  
  const response = chatWithSommelier(testHistory);
  Logger.log("Test response: " + response);
  return response;
}

/**
 * Test with image - for debugging photo upload issues
 */
function testWithImage() {
  // This won't work without actual image data, but will test the flow
  const testHistory = [
    {
      role: "user",
      parts: [
        { text: "Test message" }
      ]
    }
  ];
  
  const response = chatWithSommelier(testHistory);
  Logger.log("Test response: " + response);
  return response;
}

/**
 * Authorization helper - Run this once to grant Drive permissions
 * This triggers the OAuth authorization flow
 */
function authorizeDrive() {
  // This simple function call will trigger the authorization prompt
  const folders = DriveApp.getFolders();
  return "Drive access authorized! You can now use photo upload.";
}
